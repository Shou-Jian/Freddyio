<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="计算机网络2.0"><meta name="keywords" content="计算机网络"><meta name="author" content="Shou Jian/Freddy"><meta name="copyright" content="Shou Jian/Freddy"><title>计算机网络2.0 | Freddy.io</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Freddy.io" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">1.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-IP-%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1.  什么是 IP 地址？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-OSI-%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%88%92%E5%88%86%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">2.OSI 七层网络模型的划分？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">1.2.1.</span> <span class="toc-text">应用层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">1.2.2.</span> <span class="toc-text">传输层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">1.2.3.</span> <span class="toc-text">网络层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-number">1.2.4.</span> <span class="toc-text">数据链路层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-number">1.2.5.</span> <span class="toc-text">物理层</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-TCP-%E5%92%8C-UDP-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">3.TCP 和 UDP 有什么不同？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%EF%BC%9A"><span class="toc-number">1.3.1.</span> <span class="toc-text">连接：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">服务形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">1.3.3.</span> <span class="toc-text">可靠性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E9%83%A8%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.3.4.</span> <span class="toc-text">首部大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.5.</span> <span class="toc-text">传输方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-HTTP-%E5%92%8C-HTTPS-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">4. HTTP 和 HTTPS 的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%9A"><span class="toc-number">1.4.1.</span> <span class="toc-text">安全性：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%EF%BC%9A-1"><span class="toc-number">1.4.2.</span> <span class="toc-text">连接：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%B1%82%E9%9D%A2%EF%BC%9A"><span class="toc-number">1.4.3.</span> <span class="toc-text">技术层面：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-%E7%94%B1%E4%BA%8E%E6%98%AF%E6%98%8E%E6%96%87%E4%BC%A0%E8%BE%93%EF%BC%8C%E6%89%80%E4%BB%A5%E5%AE%89%E5%85%A8%E4%B8%8A%E5%AD%98%E5%9C%A8%E4%BB%A5%E4%B8%8B%E4%B8%89%E4%B8%AA%E9%A3%8E%E9%99%A9%EF%BC%9A"><span class="toc-number">1.4.4.</span> <span class="toc-text">HTTP 由于是明文传输，所以安全上存在以下三个风险：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS%E5%9C%A8-HTTP-%E4%B8%8E-TCP-%E5%B1%82%E4%B9%8B%E9%97%B4%E5%8A%A0%E5%85%A5%E4%BA%86-SSL-x2F-TLS%E5%8D%8F%E8%AE%AE%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BE%88%E5%A5%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E4%BA%86%E4%B8%8A%E8%BF%B0%E7%9A%84%E9%A3%8E%E9%99%A9%EF%BC%9A"><span class="toc-number">1.4.5.</span> <span class="toc-text">HTTPS在 HTTP 与 TCP 层之间加入了 SSL&#x2F;TLS协议，可以很好的解决了上述的风险：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS-%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E4%B8%8A%E9%9D%A2%E7%9A%84%E4%B8%89%E4%B8%AA%E9%A3%8E%E9%99%A9%E7%9A%84%EF%BC%9F"><span class="toc-number">1.4.6.</span> <span class="toc-text">HTTPS 是如何解决上面的三个风险的？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-cookies-%E5%92%8C-session-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">5. cookies 和 session 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-HTTP-%E7%9A%84-get-%E8%AF%B7%E6%B1%82%E5%92%8C-post-%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">6.  HTTP 的 get 请求和 post 请求的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-HTTP1-0-%E5%92%8C-HTTP1-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">7. HTTP1.0 和 HTTP1.1 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%B5%81%E7%A8%8B"><span class="toc-number">1.8.</span> <span class="toc-text">8.  Tcp三次握手四次挥手流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8-DHCP-%E8%8E%B7%E5%8F%96-IP-%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">9. 客户端使用 DHCP 获取 IP 的过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-B-x2F-S-%E5%92%8C-C-x2F-S-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.10.</span> <span class="toc-text">10.  B&#x2F;S 和 C&#x2F;S 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.11.</span> <span class="toc-text">11. 线程和进程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%93%8D%E5%BA%94%E7%A0%81"><span class="toc-number">1.12.</span> <span class="toc-text">12. 常用的响应码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E4%BA%86%E4%B8%80%E4%B8%AAurl%E5%90%8E%EF%BC%8C%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="toc-number">1.13.</span> <span class="toc-text">13.  在浏览器中输入了一个url后，请求流程是什么样的</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s1.vika.cn/space/2022/09/12/668a343b2d584517a39787dba68f8fbd"></div><div class="author-info__name text-center">Shou Jian/Freddy</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">11</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">7</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s1.vika.cn/space/2022/09/12/e9596066c4794094888ea5e53f712030)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Freddy.io</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">计算机网络2.0</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-06-10</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="1-什么是-IP-地址？"><a href="#1-什么是-IP-地址？" class="headerlink" title="1.  什么是 IP 地址？"></a>1.  什么是 IP 地址？</h3><p>​	<strong>IP 地址是指互联网协议地址</strong>。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每<strong>一个网络和每一台主机分配一个逻辑地址</strong>，以此来屏蔽物理地址的差异</p>
<p><img src="https://s1.vika.cn/space/2022/09/12/1b99e8016fa14314b33aec2b34cd673e"></p>
<h3 id="2-OSI-七层网络模型的划分？"><a href="#2-OSI-七层网络模型的划分？" class="headerlink" title="2.OSI 七层网络模型的划分？"></a>2.OSI 七层网络模型的划分？</h3><p>​	这个网络协议是分层的，网络OSI七层模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层 其中，HTTP协议处于应用层，TCP协议处于传输层。</p>
<p><img src="https://s1.vika.cn/space/2022/09/12/451fb73f3ebf4f148fd8f4d11a2f08da"></p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>电脑或手机使用的应用软件都是在应用层实现。</p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>应用层的数据包会传给传输层，传输层（Transport Layer）是为应用层提供网络支持的。</p>
<p>在传输层会有两个传输协议，分别是 TCP 和 UDP。</p>
<p>应用需要传输数据可能会非常大，如果直接传输就不好控制。</p>
<p><code>分块</code>因此当传输层的数据包大小超过 MSS（<strong>TCP 最大报文段长度</strong>） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 <strong>TCP 段（TCP Segment）</strong>。</p>
<p><code>端口号作用</code>当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是<strong>端口</strong>。<br>比如 <strong>80</strong> 端口通常是 Web 服务器用的，<strong>22</strong> 端口通常是远程登录服务器用的。</p>
<p>而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。<br>由于传输层的<strong>报文</strong>中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。</p>
<p><img src="https://s1.vika.cn/space/2022/09/12/a9b9007ab28941cf993fbc190cbe3699"></p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>实际的传输功能就交给下一层，也就是网络层（Internet Layer）。</p>
<p>网络层最常使用的是 IP 协议（Internet Protocol），IP 协议会将<strong>传输层报文作为数据部分</strong>，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会再次进行分片，得到一个即将发送到网络的 <strong>IP 报文。</strong></p>
<p>网络层<strong>负责将数据从一个设备传输到另一个设备</strong>，世界上那么多设备，又该如何找到对方呢？因此，网络层需要有区分设备的编号。<br>我们一般用 IP 地址给设备进行编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段，每段是 8 位。<br>因此，需要将 IP 地址分成两种意义：<br>一个是网络号，负责标识该 IP 地址是属于哪个子网的；<br>一个是主机号，负责标识同一子网下的不同主机；<br>怎么分的呢？这需要配合子网掩码才能算出 IP 地址 的网络号和主机号。那么在寻址的过程中，先匹配到相同的网络号，才会去找对应的主机。<br>除了寻址能力， IP 协议还有另一个重要的能力就是路由。</p>
<p>实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过算法决定下一步走哪条路径。<br>所以，IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘。</p>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>一个专门的层来<strong>标识</strong>网络中的设备，让数据在一个链路中传输，这就是数据链路层（Data Link Layer），</p>
<p>它主要为网络层提供链路级别传输的服务。</p>
<p>实际场景中，网络并不是一个整体，比如你家和我家就不属于一个网络，所以数据不仅可以在同一个网络中设备间进行传输，也可以跨网络进行传输。</p>
<p>一旦数据需要跨网络传输，就需要有一个设备同时在两个网络当中，这个设备一般是路由器，路由器可以通过路由表计算出下一个要去的 IP 地址。<br>那问题来了，路由器怎么知道这个 IP 地址是哪个设备的呢？<br>于是，就需要有一个专门的层来<strong>标识</strong>网络中的设备，让数据在一个链路中传输，这就是数据链路层（Data Link Layer），它主要为网络层提供链路级别传输的服务。</p>
<p>每一台设备的网卡都会有一个 MAC 地址，它就是用来唯一标识设备的。路由器计算出了下一个目的地 IP 地址，再通过 ARP 协议找到该目的地的 MAC 地址，这样就知道这个 IP 地址是哪个设备的了。</p>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>当数据准备要从设备发送到网络时，需要把数据包转换成电信号，让其可以在物理介质中传输，这一层就是物理层（Physical Layer），它主要是为数据链路层<strong>提供二进制传输</strong>的服务。</p>
<h3 id="3-TCP-和-UDP-有什么不同？"><a href="#3-TCP-和-UDP-有什么不同？" class="headerlink" title="3.TCP 和 UDP 有什么不同？"></a>3.TCP 和 UDP 有什么不同？</h3><p>​	TCP和UDP都是通信协议 </p>
<p>使用TCP协议在通信之前需要先建立好链接，类似于打电话一样，因此<strong>可靠性较高</strong>。<strong>缺点</strong>是比较慢。TCP协议主要应用于对数据<strong>准确性要求比较高</strong>的场景，比如一些<strong>web项目</strong>都采用了HTTP协议，HTTP底层就是TCP </p>
<p>使用UDP协议在通信前不需要提前建立链接，直接像目标ip和端口发送数据包，类似于发短信一样，因此<strong>速度快</strong>，缺点是<strong>可靠性不高</strong>，如果网络不好时，可能会<strong>丢包</strong>。UDP协议主要应用于对通信速度要求比较高，但是通信质量要求不高，比如<strong>QQ聊天</strong></p>
<h4 id="连接："><a href="#连接：" class="headerlink" title="连接："></a>连接：</h4><p><code>TCP面向连接，三次握手建立连接，UDP不需要即刻传输数据</code></p>
<h4 id="服务形式"><a href="#服务形式" class="headerlink" title="服务形式"></a>服务形式</h4><p><code>TCP只能一对一，点对点服务，UDP支持一对一、一对多、多对多通信。</code></p>
<h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><p>TCP保证数据可靠交付,拥有确认应答和重传机制,无重复、不丢失、按序到达;UDP尽可能交付,不保证可靠性。<br>4、连接控制机制<br>TCP拥有流量控制、拥塞控制，保证传输安全性等，UDP在网络拥堵情况下不会降低发送速率。</p>
<h4 id="首部大小"><a href="#首部大小" class="headerlink" title="首部大小"></a>首部大小</h4><p>TCP首部长度不适用选项字段是20字节，使用选项字段长度增加(可变),UDP首部固定8字节。</p>
<h4 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h4><p>TCP基于字节流，没有边界,但是保证传输顺序和可靠性;<br>UDP继承了IP层特性,基于数据包,有边界可能出现乱序和丢包。</p>
<p>​	TCP： 优点：可靠 稳定 </p>
<p>​	TCP 的可靠体现在 TCP 在传输数据之前，会有三次握手来建立连接，而且在数据传递时，有确认. 窗 口. 重传. 拥塞控制机制，在数据传完之后，还会断开来连接用来节约系统资源。 缺点：慢，效率低，占用系统资源高，易被攻击 </p>
<p>​	 在传递数据之前要先建立连接，这会消耗时间，而且在数据传递时，确认机制. 重传机制. 拥塞机制 等都会消耗大量时间，而且要在每台设备上维护所有的传输连接。然而，每个连接都会占用系统的 CPU，内存等硬件资源。因为 TCP 有确认机制. 三次握手机制，这些也导致 TCP 容易被利用，实现 DOS. DDOS. CC 等攻击。</p>
<p>​	UDP： 优点：快，比 TCP 稍安全  UDP 没有 TCP 拥有的各种机制，是一种无状态的传输协议，所以传输数据非常快，没有 TCP 的这些 机制，被攻击利用的机会就少一些，但是也无法避免被攻击。 缺点：不可靠，不稳定 </p>
<p>​	因为没有 TCP 的这些机制，UDP 在传输数据时，如果网络质量不好，就会很容易丢包，造成数据的缺失。 </p>
<h3 id="4-HTTP-和-HTTPS-的区别？"><a href="#4-HTTP-和-HTTPS-的区别？" class="headerlink" title="4. HTTP 和 HTTPS 的区别？"></a>4. HTTP 和 HTTPS 的区别？</h3><h4 id="安全性："><a href="#安全性：" class="headerlink" title="安全性："></a>安全性：</h4><p>HTTP 是<strong>超文本传输协议</strong>，信息是明文传输，存在安全风险的问题。</p>
<p>HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 <strong>SSL&#x2F;TLS 安全协议</strong>，使得报文能够加密传输。</p>
<h4 id="连接：-1"><a href="#连接：-1" class="headerlink" title="连接："></a>连接：</h4><p>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。HTTP 工作于<strong>应用层</strong>，HTTPS 工作于<strong>传输层</strong>。</p>
<h4 id="技术层面："><a href="#技术层面：" class="headerlink" title="技术层面："></a>技术层面：</h4><p>HTTP 的端口号是 <strong>80</strong>，HTTPS 的端口号是 <strong>443</strong>。</p>
<p>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p>
<p>HTTPS 解决了 HTTP 的哪些问题？</p>
<h4 id="HTTP-由于是明文传输，所以安全上存在以下三个风险："><a href="#HTTP-由于是明文传输，所以安全上存在以下三个风险：" class="headerlink" title="HTTP 由于是明文传输，所以安全上存在以下三个风险："></a>HTTP 由于是明文传输，所以安全上存在以下三个风险：</h4><p>窃听风险，比如通信链路上可以获取通信内容，用户号容易没。<br>篡改风险，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。<br>冒充风险，比如冒充淘宝网站，用户钱容易没。</p>
<h4 id="HTTPS在-HTTP-与-TCP-层之间加入了-SSL-x2F-TLS协议，可以很好的解决了上述的风险："><a href="#HTTPS在-HTTP-与-TCP-层之间加入了-SSL-x2F-TLS协议，可以很好的解决了上述的风险：" class="headerlink" title="HTTPS在 HTTP 与 TCP 层之间加入了 SSL&#x2F;TLS协议，可以很好的解决了上述的风险："></a>HTTPS在 HTTP 与 TCP 层之间加入了 SSL&#x2F;TLS协议，可以很好的解决了上述的风险：</h4><p><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。<br><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。<br><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。<br>可见，只要自身不做「恶」，SSL&#x2F;TLS 协议是能保证通信是安全的。</p>
<h4 id="HTTPS-是如何解决上面的三个风险的？"><a href="#HTTPS-是如何解决上面的三个风险的？" class="headerlink" title="HTTPS 是如何解决上面的三个风险的？"></a>HTTPS 是如何解决上面的三个风险的？</h4><p><strong>混合加密</strong>的方式实现信息的机密性，解决了窃听的风险。<br><strong>摘要算法</strong>的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。将服务器公钥放入到数字证书中，解决了冒充的风险。</p>
<h3 id="5-cookies-和-session-的区别？"><a href="#5-cookies-和-session-的区别？" class="headerlink" title="5. cookies 和 session 的区别？"></a>5. cookies 和 session 的区别？</h3><p>1、作用<br>1．在第一次登录服务器之后，返回一些数据(cookie)给浏览器</p>
<p>2．浏览器将数据保存在本地<br>3．两次发送请求时,自动把上一次请求存储的cookie发送给服务器</p>
<p>4、服务器通过该数据判断用户<br>2、特点<br>可存储的数据量有限,一般不会超过4KB</p>
<p>​	cookies:</p>
<p>作用：针对每一个网站的信息，每一个网站只对应一个，其它网站不能访问</p>
<p>1.在第一次登录服务器之后，返回一些数据(cookie)给浏览器2.浏览器将数据保存在<strong>本地浏览器</strong>3.两次发送请求时,自动把上一次请求存储的cookie发送给服务器4.服务器通过该数据判断用户</p>
<p>cookies 文 件的内容大致包函这些信息如用户名，密码，设置等。 </p>
<p>​	session： </p>
<p>是针对每一个用户的，只有客户机访问，程序就会在<strong>服务器</strong>上为这个客户新增一个 session。session 里主 要保存的是用户的<strong>登录信息，操作信息</strong>等。这个 session 在用户访问<strong>结束</strong>后会被<strong>自动消失</strong>（如果超时也会）。</p>
<h3 id="6-HTTP-的-get-请求和-post-请求的区别？"><a href="#6-HTTP-的-get-请求和-post-请求的区别？" class="headerlink" title="6.  HTTP 的 get 请求和 post 请求的区别？"></a>6.  HTTP 的 get 请求和 post 请求的区别？</h3><p><img src="https://s1.vika.cn/space/2022/09/12/6840d6ed9f234b748c6136d4d9686334"></p>
<p>Get方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等。</p>
<p>POST方法则是相反操作，它向 URI指定的资源提交数据，数据就放在报文的 body 里。</p>
<p>先说明下安全和幂等的概念：<br>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。<br>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</p>
<p>那么很明显 GET 方法就是安全且幂等的，因为它是「<strong>只读</strong>」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。<br>POST因为是「<strong>新增或提交数据</strong>」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。</p>
<p>区别如下： </p>
<p>实际上本质都是一样的，并无区别<br>1.都是<strong>HTTP</strong>请求协议的请求方法，而HTTP又是基于<strong>TCP&#x2F;IP</strong>的关于数据如何在万维网中如何通信的协议，所以<br>GET&#x2F;POST实际上都是<strong>TCP链接</strong><br>2.由于HTTP的规定以及浏览器&#x2F;服务器的限制，导致它们<strong>在应用过程中</strong>可能会有所不同</p>
<p>get请求可以被浏览器缓存， get请求可以直接通过浏览器访问，支持刷新和后退。post请求不能被缓存 ，post请求不能直接使用浏览器访问，刷新后数据要重新发送。</p>
<p>post请求参数放在报文的body中，安全性相对较好，请求信息长度没有限制。get请求参数放在url里，url的长度是受限的，最大为2048个字符。</p>
<h3 id="7-HTTP1-0-和-HTTP1-1-有什么区别？"><a href="#7-HTTP1-0-和-HTTP1-1-有什么区别？" class="headerlink" title="7. HTTP1.0 和 HTTP1.1 有什么区别？"></a>7. HTTP1.0 和 HTTP1.1 有什么区别？</h3><p>​	HTTP 协议老的标准是 HTTP&#x2F;1.0，目前最通用的标准是 HTTP&#x2F;1.1。  在同一个 tcp 的连接中可以传送多个 HTTP 请求和响应. 多个请求和响应可以重叠，多个请求和响应可以同时进行. 更加多的请求头和响应头(比如 HTTP1.0 没有 host 的字段). </p>
<p>​	它们最大的区别： </p>
<p>使用 TCP 长连接的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。<br>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</p>
<p>在 HTTP&#x2F;1.0 中,大多实现为每个请求&#x2F;响应交换使用新的连接。HTTP 1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接， 服务器不跟踪每个客户也不记录过去的请求。 </p>
<p>​	在 HTTP&#x2F;1.1 中,一个连接可用于一次或多次请求&#x2F;响应交换,尽管连接可能由于各种原因被关闭。HTTP  1.1 支持持久连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。 一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和 应答仍然需要使用各自的连接。HTTP 1.1 还允许客户端不用等待上一次请求结果返回，就可以发出下一次请 求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请 求的响应内容，这样也显著地减少了整个下载过程所需要的时间。</p>
<h3 id="8-Tcp三次握手四次挥手流程"><a href="#8-Tcp三次握手四次挥手流程" class="headerlink" title="8.  Tcp三次握手四次挥手流程"></a>8.  Tcp三次握手四次挥手流程</h3><p><img src="https://s1.vika.cn/space/2022/09/12/896283de93d74eac970c8377c4b65266"></p>
<p>1.第一个SYN报文：</p>
<p>客户端随机初始化序列号client_isn，放进TCP首部序列号段，然后把SYN 同步序列编号（<em>Syn</em>chronize Sequence Numbers）置1。把SYN报文发送给服务端，表示发起连接，之后客户端出于SYN-SENT状态。</p>
<p>2.第二个报文SYN+ACK报文：</p>
<p>服务端收到客户端的SYN报文，把自己的序号server_isn放进TCP首部序列号段，确认应答号填入client_ins + 1，把SYN+ACK置1，把SYN+ACK报文发送个客户端，然后进入SYN-RCVD状态。</p>
<p>3.第三个报文ACK (<em>Ack</em>nowledge character）即是确认字符：</p>
<p>客户端收到服务端报文后，还要向服务端回应最后一个应答报文。首先该应答报文TCP首部ACK标志位置为1，其次确认应答号字段填入server_isn + 1,最后把报文发送给服务端，这次报文可以携带客户到服务器的数据之后客户端出于ESTABLISHED状态。</p>
<p>服务器收到客户端的应答报文后，也进入ESTABLISHED状态。</p>
<p>为什么需要三次握⼿？ 总结： </p>
<ol>
<li>三次握手才可以阻止重复历史连接的初始化（主因）</li>
<li>三次握手才可以同步双方的初始序列号</li>
<li>三次握手CIA可以避免资源浪费</li>
</ol>
<p><img src="https://s1.vika.cn/space/2022/09/12/c71c861e72064b049fdab57c988b67b2"></p>
<p><img src="https://s1.vika.cn/space/2022/09/12/de57f80dbd1c4ce98093feaf446c2b19"></p>
<p><img src="https://s1.vika.cn/space/2022/09/12/8de1ba8d29db4b09b72f98f5d5b65412"></p>
<p><img src="https://s1.vika.cn/space/2022/09/12/af87bfb458ce4f5a8c396dfe3d033734"></p>
<p><img src="https://s1.vika.cn/space/2022/09/12/f9c280dac55e495dafc971b81fabd742"></p>
<h3 id="9-客户端使用-DHCP-获取-IP-的过程？"><a href="#9-客户端使用-DHCP-获取-IP-的过程？" class="headerlink" title="9. 客户端使用 DHCP 获取 IP 的过程？"></a>9. 客户端使用 DHCP 获取 IP 的过程？</h3><p>​	发现阶段：即 DHCP 客户端寻找 DHCP 服务器的阶段。 提供阶段：即 DHCP 服务器提供 IP 地址的阶段。 选择阶段：即 DHCP 客户端选择某台 DHCP 服务器提供的 IP 地址的阶段。 确认阶段：即 DHCP 服务器确认所提供的 IP 地址的阶段。</p>
<h3 id="10-B-x2F-S-和-C-x2F-S-的区别"><a href="#10-B-x2F-S-和-C-x2F-S-的区别" class="headerlink" title="10.  B&#x2F;S 和 C&#x2F;S 的区别"></a>10.  B&#x2F;S 和 C&#x2F;S 的区别</h3><p>​	b&#x2F;s 代表浏览器和服务器架构；c&#x2F;s 代表客户端和服务器架构 </p>
<p>​	网络环境不同（c&#x2F;s 建立在专用的局域网上，b&#x2F;s 建立在广域网上） </p>
<p>​	安全要求不同（c&#x2F;s 必须安装客户端，安全度较高；b&#x2F;s 安全度较低） </p>
<p>​	系统维护不同（c&#x2F;s 升级困难，需要重新安装最新客户端；b&#x2F;s 无缝升级） </p>
<p>​	对系统要求不同（c&#x2F;s 对系统要求较高；b&#x2F;s 对系统要求较低）</p>
<h3 id="11-线程和进程的区别"><a href="#11-线程和进程的区别" class="headerlink" title="11. 线程和进程的区别"></a>11. 线程和进程的区别</h3><p>进程——资源分配的最小单位，线程——程序执行的最小单位。</p>
<p>线程又称为轻量级进程，进程有进程控制块，线程有线程控制块</p>
<p>属于同一个进程的所有线程共享该进程的所有资源，包括文件描述符。而不同过的进程相互独立。</p>
<p>线程必定也只能属于一个进程，而进程可以拥有多个线程而且至少拥有一个线程；</p>
<p>比如公司就是一个进程，公司的员工就是线程。线程占用的资源要⽐进程少很多。线程之间通信比进程更方便</p>
<p> 线程进程的区别体现在几个方面： </p>
<p>第一：进程有自己独立的地址空间，每启动一个进程，系统都会为其分配地址空间，建立数据表来维护代码段、堆栈段和数据段，线程没有独立的地址空间，它使用相同的地址空间共享数据，系统开销比较大。CPU切换一个线程比切换进程花费小;创建一个线程比进程开销小。线程占用的资源要比进程少很多。</p>
<p>第二：线程之间通信更方便，同一个进程下，线程共享全局变量，静态变量等数据，进程之间的通信需要以通信的方式（IPC）进行;(但多线程程序处理好同步与互斥是个难点)。多进程程序更安全，生命力更强，一个进程死掉不会对另一个进程造成影响(源于有独立的地址空间)，多线程程序更不易维护，一个线程死掉，整个进程就死掉了（因为共享地址空间);</p>
<h3 id="12-常用的响应码"><a href="#12-常用的响应码" class="headerlink" title="12. 常用的响应码"></a>12. 常用的响应码</h3><p>​	反映了 web 服务器处理 HTTP 请求状态，每一个响 应码都代表了一种服务端反馈的响应状态，标识了本次请求是否成功。</p>
<p><img src="https://s1.vika.cn/space/2022/09/12/f9e70482bb7f40e7a1329f155cde645f"></p>
<p><img src="https://s1.vika.cn/space/2022/09/12/8bc8c2c89cdf4eb6a46043809a458d08"></p>
<h3 id="13-在浏览器中输入了一个url后，请求流程是什么样的"><a href="#13-在浏览器中输入了一个url后，请求流程是什么样的" class="headerlink" title="13.  在浏览器中输入了一个url后，请求流程是什么样的"></a>13.  在浏览器中输入了一个url后，请求流程是什么样的</h3><p>​	1.DNS域名解析 2、与服务器建立TCP连接 3、发起HTTP请求，发送数据 4、服务器响应HTTP请求，返回数据 5、浏览器解析数据、渲染 6、关闭TCP连接</p>
<p><img src="https://s1.vika.cn/space/2022/09/12/a971743de435476fbf0611115f9aa12c"></p>
<p><img src="https://s1.vika.cn/space/2022/09/12/d1b17018859e48b6b3fab649c3d63d91"></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Shou Jian/Freddy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/06/10/计算机网络/">http://example.com/2022/06/10/计算机网络/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/06/15/MySQL%E7%B4%A2%E5%BC%95/"><i class="fa fa-chevron-left">  </i><span>MySQL索引</span></a></div><div class="next-post pull-right"><a href="/2022/05/25/Python/"><span>Python3基础 2.0</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s1.vika.cn/space/2022/09/12/e9596066c4794094888ea5e53f712030)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2022 By Shou Jian/Freddy</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>